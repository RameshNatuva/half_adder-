Combinational circuits

1.basic

1.half adder

Verilog code

1.data flow 
`timescale 1ns / 1ps
module ha(a,b,sum,carry);
   input a,b ;
    output sum, carry;    
  assign  sum=a^b;
  assign  carry=a&b;
endmodule
2.gate level code
`timescale 1ns / 1ps
module ha(a,b,sum,carry);
    input a,b ;
    output sum, carry;    
 xor (sum, a, b);   // XOR gate for sum
 and (carry, a, b); // AND gate for carry
endmodule
3.behaviourl code
`timescale 1ns / 1ps
module ha(a,b,sum,carry);
    input a,b ;
    output sum, carry;
    reg sum,carry;
    always @(a,b)
     begin
        sum   = a ^ b;  // XOR for sum
        carry = a & b;  // AND for carry
    end
endmodule



test bench code


`timescale 1ns / 1ps
module ha_tb;
    reg a,b;
    wire sum,carry;
    ha uut(.a(a),.b(b),.sum(sum),.carry(carry));
    initial begin
        a=0;b=0;#10;
        a=0;b=1;#10;
        a=1;b=0;#10;
        a=1;b=1;#10;
        $finish;
    end
endmodule











2.full adder


verilog code


1.GATE LEVEL MODEL

`timescale 1ns / 1ps
module full_add(a,b,c,sum,carry);
input a,b,c;
output sum,carry;
wire [3:0] w;
xor g1(w[0],a,b);
xor g2(sum,c,w[0]);
and g3(w[1],a,b);
and g34(w[2],b,c);
and g4(w[3],a,c);
or g5(carry ,w[1],w[2],w[3]);
endmodule

2.DATA FLOW MODEl
`timescale 1ns / 1ps
module full_add(a,b,c,sum,carry);
input a,b,c;
output sum,carry;
wire [3:0] w;
assign w[0]=a^b;
assign sum=w[0]^c;
assign w[1]=a^b;
assign w[2]=a^c;
assign w[3]=c^b;
assign carry=w[1]|w[2]|w[3];
endmodule


3.BEHAVIOURAL MODEL
`timescale 1ns / 1ps
module full_adder(input a, input b, input c, output reg sum, output reg carry);
    always @(*) begin
        sum = a ^ b ^ c;
        carry = (a & b) | (b & c) | (a & c);
    end
endmodule




TEST BENCH  CODE

`timescale 1ns / 1ps
module full_add_tb;
    reg a,b,c;  
    wire sum,carry;
    full_add uut(.a(a),.b(b),.c(c),.sum(sum),.carry(carry));
    initial begin
        a=0;b=0;c=0;#10;
        a=0;b=0;c=1;#10;
        a=0;b=1;c=0;#10;
        a=0;b=1;c=1;#10;
        a=1;b=0;c=0;#10;
        a=1;b=0;c=1;#10;
        a=1;b=1;c=0;#10;
        a=1;b=1;c=1;#10;
       $finish;
    end
endmodule




3.HALF SUBSTRACTER


VERILOG  CODE

1.GATE LEVEL MODELING

`timescale 1ns / 1ps
module half_sub(input a,input b,output diff,output borrow);
wire w1;
xor e2(diff,a,b);
not e4(w1,a);
and e3(borrow,w1,b);
endmodule

2.DATA FLOW MODEL
`timescale 1ns / 1ps
module half_sub(input a,input b,output diff,output borrow);
assign diff = a ^ b;
assign borrow =(~a) & b;
endmodule

3.BEHAVIOURAL MODEL 

`timescale 1ns / 1ps
module half_subtractor(input a,input b,output reg diff,output reg borrow);
always @(a,b)
 begin
    diff = a ^ b;
    borrow = ~a & b;
end
endmodule


TEST BENCH CODE

`timescale 1ns / 1ps
module half_sub_tb;
reg a,b;
wire diff,borrow;
half_sub uut(.a(a),.b(b),.diff(diff),.borrow(borrow));
initial begin
a=0;b=0;#10;
a=0;b=1;#10;
a=1;b=0;#10;
a=1;b=1;#10;
$finish;
end
endmodule
 


4.FULL SUBSTRACTER 


VERILOG CODE

1.GATE LEVEL MODEL

`timescale 1ns / 1ps
module full_sub(input a,input b,input bin,output diff,output borrow);
wire w1,w2,w3,w4,w5;
xor e2(w1,a,b);
xor e3(diff,w1,bin);
not e4(w2,a);
and e5(w3,w2,b);
and e6(w4,w2,bin);
and e7(w5,bin,b);
or e8(borrow ,w3,w4,w5);
endmodule


2.DATA FLOW MODEL 

`timescale 1ns / 1ps
module full_sub(input a,input b,input bin,output diff,output borrow);
assign diff = a ^ b ^ bin;
assign borrow = (~a & b) | (~a & bin) | (b & bin);
endmodule


3.BEHAVIOURAL MODEL

`timescale 1ns / 1ps
module full_sub(input a,input b,input bin,output reg diff,output reg borrow);
always @(a,b,bin) 
begin
    diff = a ^ b ^ bin;
    borrow = (~a & b) | (~a & bin) | (b & bin);
end
endmodule




TEST BENCH


`timescale 1ns / 1ps
module full_sub_tb;
reg a,b,bin;
wire diff,borrow;
full_sub uut(.a(a),.b(b),.bin(bin),.diff(diff),.borrow(borrow));
initial begin
a=0;b=0;bin=0;#10;
a=0;b=0;bin=1;#10;
a=0;b=1;bin=0;#10;
a=0;b=1;bin=1;#10;
a=1;b=0;bin=0;#10;
a=1;b=0;bin=1;#10;
a=1;b=1;bin=0;#10;
a=1;b=1;bin=1;#10;
$finish;
end
endmodule





4-bit PARALLEL BIMARY ADDER

`timescale 1ns / 1ps

module f_a(input a, input b, input c, output s, output co);
wire [2:0] w;
xor g1(s, a, b, c);
and g2(w[0], a, b);
and g3(w[1], c, b);
and g4(w[2], a, c);
or g5(co, w[0], w[1], w[2]);
endmodule

module parallel_adder(output [3:0] s, input [3:0] a, input [3:0] b, input c0, output c4);
wire [2:0] w;

f_a add1(a[0], b[0], c0, s[0], w[0]);
f_a add2(a[1], b[1], w[0], s[1], w[1]);
f_a add3(a[2], b[2], w[1], s[2], w[2]);
f_a add4(a[3], b[3], w[2], s[3], c4);

endmodule

5. 8:1 multiplexer using 2:1 MUXe



`timescale 1ns / 1ps
module instantiation(a,b,s,y);
input a,b;
input s;
output y;
wire [1:0]x;
assign x[0]=((~s)&a);
assign x[1]=s&b;
assign y=x[0] | x[1];
endmodule 

module mux_8_1(i,s,y );
input [7:0]i;
input [2:0]s;
output y;
wire [5:0]w;
instantiation mux1(i[0],i[1],s[0],w[0]);
instantiation mux2(i[2],i[3],s[0],w[1]);
instantiation mux3(i[4],i[5],s[0],w[2]);
instantiation mux4(i[6],i[7],s[0],w[3]);
instantiation mux66(w[0],w[1],s[1],w[4]);
instantiation mux64(w[2],w[3],s[1],w[5]);
instantiation mux466(w[4],w[5],s[2],y);
endmodule 









EXAMPLE CODE USING CASE STATEMENTS(behavioural modeling )
`timescale 1ns / 1ps
module cases(a,b,c,s);
input a,b;
output reg  s,c;
always @(a,b)
begin 
case({a,b})
        2'b00: {s, c} = 2'b00;
        2'b01: {s, c} = 2'b10;
        2'b10: {s, c} = 2'b10;
        2'b11: {s, c} = 2'b01;
endcase
end
endmodule






6.VERILOG CODE FOR 3BIT MAGNITUDE CAMPARATOR 


`timescale 1ns / 1ps
module comp_3_bit(a,b,e,g,l);
input [2:0]a;
input [2:0]b;
output reg  e,g,l;
always @(a,b)
begin 
if (a[2]>b[2]) begin
    e=1'b0;g=1'b1;l=1'b0;
end 
else if (a[2]==b[2])
        begin
        if (a[1]>b[1]) begin 
               e=1'b0;g=1'b1;l=1'b0;end
        else if  (a[1]==b[1]) begin
                if  (a[0]>b[0]) begin
                    e=1'b0;g=1'b1;l=1'b0; end
                else if (a[0]==b[0]) begin
                        e=1'b1;g=1'b0;l=1'b0; end
                else begin
                       e=1'b0;g=1'b0;l=1'b1; end
         end
         else 
          e=1'b0;g=1'b0;l=1'b1;
         end
 else  begin
    e=1'b0;g=1'b0;l=1'b1; end
end
endmodule



								**** TEST BENCH****
`timescale 1ns / 1ps
module comp_3_bit_tb;
reg [2:0]a;
reg [2:0]b;
wire e,g,l;

comp_3_bit uut(.a(a),.b(b),.e(e),.g(g),.l(l));

initial begin


a=3'b001; b=3'b010; #10 $display("%0dns\t%b\t%b\t| %b %b %b",$time,a,b,e,g,l);
a=3'b101; b=3'b011; #10 $display("%0dns\t%b\t%b\t| %b %b %b",$time,a,b,e,g,l);
a=3'b111; b=3'b111; #10 $display("%0dns\t%b\t%b\t| %b %b %b",$time,a,b,e,g,l);
a=3'b000; b=3'b001; #10 $display("%0dns\t%b\t%b\t| %b %b %b",$time,a,b,e,g,l);
a=3'b100; b=3'b011; #10 $display("%0dns\t%b\t%b\t| %b %b %b",$time,a,b,e,g,l);
a=3'b010; b=3'b010; #10 $display("%0dns\t%b\t%b\t| %b %b %b",$time,a,b,e,g,l);

$finish;
end
endmodule




7.PARALLEL SUBSTRATER  

`timescale 1ns / 1ps

module f_a(input a, input b, input c, output s, output co);
    wire [2:0] w;
    xor g1(s, a, b, c);
    and g2(w[0], a, b);
    and g3(w[1], c, b);
    and g4(w[2], a, c);
    or g5(co, w[0], w[1], w[2]);
endmodule

module parallel_adder(output [3:0] s, input [3:0] a, input [3:0] b, input c0, output c4);
    wire [2:0] w;
    f_a add1(a[0], b[0], c0, s[0], w[0]);
    f_a add2(a[1], b[1], w[0], s[1], w[1]);
    f_a add3(a[2], b[2], w[1], s[2], w[2]);
    f_a add4(a[3], b[3], w[2], s[3], c4);
endmodule

module parallel_subtractor(output [3:0] diff, input [3:0] a, input [3:0] b, output borrow);
    wire [3:0] b_comp;
    assign b_comp = ~b;  // 1's complement of b
    parallel_adder sub(diff, a, b_comp, 1'b1, borrow);
endmodule






9.MUX

`timescale 1ns / 1ps
module mux(i,s,y);
input [7:0]i;
input [2:0]s;
output reg  y;
always@(i,s)
begin
case ({s[2],s[1],s[0]})
        3'b000: y = i[0];
        3'b001: y = i[1];
        3'b010: y = i[2];
        3'b011: y = i[3];
        3'b100: y = i[4];
        3'b101: y = i[5];
        3'b110: y = i[6];
        3'b111: y = i[7];
endcase
end
endmodule

					**** TEST BENCH *****



`timescale 1ns / 1ps
module tb_mux;
reg [7:0] i;

reg [2:0] s;
wire y;
mux uut(i, s, y);
initial begin
i=8'b10101010;
s=3'b000; #10;
s=3'b001; #10;
s=3'b010; #10;
s=3'b011; #10;
s=3'b100; #10;
s=3'b101; #10;
s=3'b110; #10;
s=3'b111; #10;
$finish;
end
endmodule



10.DEMUX

`timescale 1ns / 1ps
module demux(a,s,y);
input a;
input [2:0]s;
output reg [7:0]y;

always@(a,s)
begin
case ({s[2],s[1],s[0]})
        3'b000: y[0]=a;
        3'b001: y[1]=a;
        3'b010: y[2]=a;
        3'b011: y[3]=a;
        3'b100: y[4]=a;
        3'b101: y[5]=a;
        3'b110: y[6]=a;
        3'b111: y[7]=a;
        endcase 
        end
endmodule




							*** TEST BECNH ****

`timescale 1ns / 1ps
module tb_demux;
reg a;
reg [2:0] s;
wire [7:0] y;
demux uut(a, s, y);
initial begin
a = 1;
s = 3'b000; #10;
s = 3'b001; #10;
s = 3'b010; #10;
s = 3'b011; #10;
s = 3'b100; #10;
s = 3'b101; #10;
s = 3'b110; #10;
s = 3'b111; #10;
$finish;
end
endmodule




11.decoder 

`timescale 1ns / 1ps
module decoder_3_to_8(input [2:0] in, output reg [7:0] out,input en);
always @(in) begin
if (en==0) begin 
    out = 8'b00000000; end
else
begin
case(in)
3'b000: out = 8'b00000001;
3'b001: out = 8'b00000010;
3'b010: out = 8'b00000100;
3'b011: out = 8'b00001000;
3'b100: out = 8'b00010000;
3'b101: out = 8'b00100000;
3'b110: out = 8'b01000000;
3'b111: out = 8'b10000000;
default: out = 8'b00000000;
endcase
end
end
endmodule



					**&*& TEST BECNCH****

`timescale 1ns / 1ps
module tb_decoder_3_to_8;
reg [2:0] in;
wire [7:0] out;
decoder_3_to_8 uut(in, out);
initial begin 
in=3'b000; #10;
in=3'b001; #10;
in=3'b010; #10;
in=3'b011; #10;
in=3'b100; #10;
in=3'b101; #10;
in=3'b110; #10;
in=3'b111; #10;
$finish;
end
endmodule




12.ENCODER 


`timescale 1ns / 1ps
module encoder(input [7:0] in, output reg [2:0] out,input en);
always @(in) begin
if (en==0) begin 
    out = 3'b000; end
else
begin
case(in)
8'b10000000: out = 3'b111;
8'b01000000: out = 3'b110;
8'b00100000: out = 3'b101;
8'b00010000: out = 3'b100;
8'b00001000: out = 3'b011;
8'b00000100: out = 3'b010;
8'b00000010: out = 3'b001;
8'b00000001: out = 3'b000;
default: out = 3'b000;
endcase
end
end
endmodule


						*i*****TESTBECNH****


`timescale 1ns/1ps
module encoder_tb;
reg[7:0]in;
reg en;
wire[2:0]out;
encoder uut(.in(in),.out(out),.en(en));
initial begin
en=0;in=8'b10000000;#10;
en=1;in=8'b00000001;#10;
in=8'b00001000;#10;
in=8'b10000000;#10;
in=8'b00001100;#10;
in=8'b00100000;#10;
in=8'b00000000;#10;
$finish;
end
endmodule



